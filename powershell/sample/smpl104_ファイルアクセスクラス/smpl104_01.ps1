#==============================================================================
# ファイルアクセスクラス
#==============================================================================
class CComFileAccess {
    # メンバ
    $filePath
    $fileData
    $arrStrHeader    # ヘッダ行と判定する文字列
    $funcRecProc
    $delimiter

    #============================================================
    # コンストラクタ
    #------------------------------------------------------------
    # 引数 : なし
    #============================================================
    CComFileAccess(){
        $this.filePath = ""
        $this.fileData = ""
        $this.arrStrHeader = @()
        $this.delimiter = " "
    }

    #============================================================
    # ファイルパス設定
    #------------------------------------------------------------
    # 引数   : $pFilePath : ファイルパス
    # 戻り値 : なし
    #============================================================
    [void] SetFilePath($pFilePath){
        $this.filePath = $pFilePath
    }

    #============================================================
    # デリミタ設定
    #------------------------------------------------------------
    # 引数   : $pDelimiter : デリミタ
    # 戻り値 : なし
    #============================================================
    [void] SetDelimiter($pDelimiter){
        $this.delimiter = $pDelimiter
    }

    #============================================================
    # ファイル読み込み
    #------------------------------------------------------------
    # 引数   : $pFilePath : ファイルパス
    # 戻り値 : なし
    #============================================================
    [void] ReadFile($pFilePath){
        $this.filePath = $pFilePath
        $this.fileData = Get-Content $this.filePath
    }

    #============================================================
    # ファイル書き込み
    #------------------------------------------------------------
    # 引数   : なし
    # 戻り値 : なし
    #============================================================
    [void] WriteFile(){
        Set-Content $this.filePath $this.fileData
    }

    #============================================================
    # ファイル書き込み(データ指定)
    #------------------------------------------------------------
    # 引数   : $pObjData : 出力データ
    # 戻り値 : なし
    #------------------------------------------------------------
    # 出力データは、文字列 or 配列 or カスタムオブジェクトの配列で指定
    # 文字列指定                : そのまま出力
    # 配列指定                  : CSV出力
    # カスタムオブジェクト指定   : CSV出力
    #============================================================
    [void] WriteFileData($pData){
        if ($pData.Length -le 0){
            return
        }

        $outData = $pData

        # データが文字列(CSV)以外は変換
        if ($pData[0].GetType().Name -ne "string"){
            $cnv = New-Object CComCnvData
            $cnv.SetDelimiter($this.delimiter)
            $outData = $cnv.DataToCsv($outData)
        }

        $this.fileData = $outData
        $this.WriteFile()
    }

    #============================================================
    # データリスト取得
    #------------------------------------------------------------
    # 引数   : なし
    # 戻り値 : データリスト
    #============================================================
    [object[]] GetData(){
        return $this.fileData
    }

    #============================================================
    # データリスト取得(ヘッダ除外)
    #------------------------------------------------------------
    # 引数   : なし
    # 戻り値 : データリスト
    #============================================================
    [object[]] GetDataNotHeader(){
        # ヘッダ以外
        return $this.fileData | Where-Object {-not ($this.CheckHeader($_))}
    }

    #============================================================
    # データリスト取得(項目値で抽出)(ヘッダ除外)
    #------------------------------------------------------------
    # 引数   : $pWhere : 抽出項目値(項目IDXと抽出項目値のハッシュテーブル)
    # 戻り値 : データリスト
    #------------------------------------------------------------
    # 抽出項目値との一致判定は -cLike で判定する
    #============================================================
    [object[]] GetDataWhere($pWhereList){
        return $this.fileData | Where-Object {
            $ret = $true
            if ($this.CheckHeader($_)){
                $ret = $false    
            }
            else {
                $arr = $_.Split($this.delimiter)             
                foreach($key in $pWhereList.Keys){
                    $val = $pWhereList[$key]
                    if (-not ($arr[$key] -cLike $val)){
                        $ret = $false    
                        break
                    }
                }
            }
            return $ret
        }
    }

    #============================================================
    # データリスト取得(カスタムオブジェクト)(ヘッダ除外)
    #------------------------------------------------------------
    # 引数   : $pWhere : 抽出項目値(項目IDXと抽出項目値のハッシュテーブル)
    # 戻り値 : データリスト
    #------------------------------------------------------------
    # 抽出項目値との一致判定は -cLike で判定する
    #============================================================
    [object[]] GetDataCustomObj(){
        $objData = @()
        if ($this.fileData.Length -le 0){
            return $objData
        }

        #ヘッダから列名を取り出す
        $colNames = $this.fileData[0].Split($this.delimiter).Trim()

        $this.fileData | ForEach-Object {
            if ( -not $this.CheckHeader($_)){
                # ハッシュを作成
                $hashData=[ordered]@{}    

                $arr = $_.Split($this.delimiter)             

                for ($i = 0 ; $i -lt $colNames.Length ; $i++){
                    if ($arr.Length -gt $i){
                        $hashData += @{$colNames[$i] = $arr[$i]}
                    }
                    else {
                        $hashData += @{$colNames[$i] = ""}
                    }
                }
                # ハッシュからカスタムオブジェクトにキャスト
                $objData += [pscustomobject]$hashData
            }
        }
        return $objData
    }

    #============================================================
    # ヘッダ判定文字列設定
    #------------------------------------------------------------
    # 引数   : $pArrStrHeader : ヘッダ判定文字列の配列
    # 戻り値 : なし
    #============================================================
    [void] SetStrHeader([string[]]$pArrStrHeader){
        $this.arrStrHeader = $pArrStrHeader
    }

    #============================================================
    # ヘッダ判定
    #------------------------------------------------------------
    # 引数   : $pRec : 判定対象のレコード
    # 戻り値 : ヘッダレコードの場合:$true, 以外:$false
    #============================================================
    [bool] CheckHeader($pRec){
        $ret = $false

        $arr = -Split $pRec
        if ($this.arrStrHeader -contains $arr[0]){
            $ret = $true
        }

        return $ret
    }

    #============================================================
    # レコード処理設定
    #------------------------------------------------------------
    # 引数   : $pRecProc : レコード処理関数
    # 戻り値 : なし
    #============================================================
    [void] SetRecProc($pRecProc){
        $this.funcRecProc = $pRecProc
    }

    #============================================================
    # レコード処理実行
    #------------------------------------------------------------
    # 引数   : なし
    # 戻り値 : なし
    #============================================================
    [void] ExecRecProc(){
        $this.GetDataNotHeader() | ForEach-Object $this.funcRecProc
    }
}
